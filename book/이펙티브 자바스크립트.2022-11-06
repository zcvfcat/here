1장 자바스크립트에 익숙해지기
  1 어떤 자바스크립트를 사용하고 있는지 알아야 한다
    js는 ecmascript 표준 시스템(esm)과 다양한 시스템(commonjs, amd)과 양립하고 있음
    다양한 클라이언트(웹브라우저), 서버 측 프로그램을 통합해야할 필요성이 있음
      - 비표준 배제 (방법 처음 스크립트 실행시 "use strict") - 스트릭트 모드 활성화
      - 스트릭트 모드, 일반 모드 병합하면 안됨
    `어떤 환경이든 동일한 동작을 하도록 코드 작성`

  2 자바스크립트의 부동 소수점 숫자 이해하기
    number 객체 IEEE 754 구현
    toString(2) 이진수 변환, parseInt("1001",2) 이진수 검증
    부동 소수점(float point = .) 연산의 문제점이 명확
    0.1 + 0.2 부동 소수점 문제를 정수로 변환해서 처리

  3 암묵적인 형변환을 주의하라
    정확한 타입으로 형변환 하자
    +"1" -> Number("1") 단일 연산자로 형변환 하지마라, isNaN 정상적인 리턴값 기대하기 힘듬
    falsy truthy 쓰지말자

  4 객체 래퍼보다 원시 데이터형을 우선시하라
    js는 boolean, number, string, null, undefined 만 원시형 나머진 객체
    new String(x) 쓰지말고 String(x) 써라

    원시 데이터형을 위한 객체 래퍼는 원시형 데이터와 다르다

  5 혼합된 데이터형을 ==로 비교하지 마라
    == 서로 다른 데이터일 경우 `강제 형변환` 후 비교
    ===, !== 데이터 형 비교, 값 비교 쓰자

    명시적으로 프로그램의 동작을 적자 - 신뢰성

  6 세미콜론 삽입의 한계에 대해서 알아두자
    세미콜론(;)은 파싱단계에서 자동적으로 넣어줌
    반복문 조건절에는 자동적으로 삽입 안됨

    스크립트 병합시 스크립트 사이에 세미콜론 삽입(;) <- 코드 방어

  7 문자열을 16비트 코드 단위의 시퀀스로 간주하라
    문자열이 유니코드 포인트가 아닌 16비트 코드 유닛으로 구성
    문자열 위치, 길이 문자열 조작하기등은 라이브러리(encodeURIComponent, encodeURI ...) 사용하자

2장 변수 스코프
  8 전역 객체의 사용을 최소화하라
    다른 곳에서 사용 될 수 있음을 인지
    모듈을 응집도를 높이기 위해 제거하라
    대신 환경변수를 사용하자

  9 항상 지역 변수를 선언하라 - 구식
  지역변수 let, const 쓰자

  10 with를 사용하지 마라 - 당연히 쓰면 안됨
  어느 위치에서든 객체의 기능 재선언 - 신뢰성

  11 클로저에 익숙해져라
    함수 호출시 자신의 위치를 기억하고 있음
    외부 스코프에 선언된 변수 참조 가능

  12 변수 호이스팅에 대해 이해하라
    for (var ... 변수들 재선언되니까 var 변수 쓰지말자
    굳이 쓴다면 직접 호이스팅 (스코프 맨 위에 선언)
    지역변수 let, const 쓰자

  13 지역 변수 스코프를 만들기 위해 즉시 실행 함수 표현식을 사용하라
    지역변수 let, const 쓰자

  14 기명 함수 표현식의 스코프에 주의하라
    var 그냥 쓰지말자

  15 블록-지역 함수 선언문의 스코프에 주의하라
    내부 선언된 함수가 실행환경에 따라 다르게 동작 할 수 있으므로 외부에 선언

  16 eval을 이용해 지역 변수를 생성하지 마라
    문자열로 외부에서 실행되므로 사용하지마라
    xss와 사용방법과 비슷

  17 직접적인 eval보다 간접적인 eval을 사용하라
    이 단원 그냥 보지마라
    알면 안되는 것들임

3장 함수 사용하기
  19 함수, 메서드, 생성자 호출의 차이를 이해하라
    new 연산자와 함수를 활용하여 객체를 생성가능
    함수의 리턴값을 객체로 둘 경우 함수를 생성자 형태로 사용가능

  20 고차 함수에 익숙해져라
    고차 함수는 다른 함수를 인수를 받아서 사용하는 함수
    고차 함수를 활용 경우 스코프의 경계선을 인지해야함

  21 지정된 수신자 객체로 함수를 호출하기 위해 call 메서드를 사용하라
    객체에 임시 프로퍼티를 삽입안 하는 것이 좋다 - obj.temporary = f X

    Object.call로 객체의 속성이 있는지 파악가능
    
  22 다른 개수의 인자로 함수를 호출하기 위해 apply를 사용하라
    Object.apply로 함수의 내부 가변인자를 주입가능...
    
  23 가변 인자 함수를 생성하기 위해 arguments를 사용하라
    암묵적인 지역 변수인자 arguments를 가변인자 사용가능...

  24 절대 arguments 객체를 수정하지 마라
    
  26 고정된 수신자 객체로 메서드를 추출하기 위해 bind를 사용하라
    bind는 호출된 함수인자의 this 인자를 변경
    객체의 메서드의 인자는 수신한 객체의 함수의 수신자의 this가 바인딩 된다
  
  27 커링 함수에 bind를 사용하라
    bind 함수를 사용하여 함수 인자를 넣어서 새로운 함수를 만들 수 있다

  28 코드를 캡슐화하기 위해 문자열보다 클로저를 사용하라
    eval로 문자열 코딩 넣지말고 클로저 사용하자

  29 함수의 toString 메서드에 의존하지 마라
    toString에 다형성을 추가하지마라 - 엔진마다 다른 결과물이 나올 수 있다
    toString 재선언시 클로저의 보관된 값들이 노출되지 않는다

  30 비표준 스택 검사 프로퍼티를 사용하지 마라
    argument.caller, argument.callee의 신뢰하지 못한다.

4장 객체와 프로토타입
  31 __proto__보다 Object.getPrototypeOf를 사용하라
    객체.prototype은 new 객채()의 프로토 타입
    Object.getPrototypeOf(객체)로 객체의 프로토 타입 확인 가능
    __proto__은 비표준이다.

  32 __proto__를 절대 수정하지 마라
    __proto__로 객체의 프로토타입 링크를 수정가능하지만 모든 시스템에서 동일하게 동작 안할 수 있다.

  33 생성자가 new와 관계 없이 동작하게 만들어라

  34 메서드를 프로토타입에 저장하라
    인스턴스 객체마다 똑같은 메서드가 바인딩 될 수 있으므로 프로토타입으로 주자

  35 비공개 데이터를 저장하기 위해 클로저를 사용하라
    자바스크립트는 강제 메커니즘이 아닌 코딩 컨벤션에 의존
    클로저는 비공개, 내부에서만 접근 가능

  36 인스턴스의 상태는 인스턴스 객체에만 저장하라
    배열을 프로토타입에 선언할 경우 해당 객체로 선언한 것들이 전부 공유가 됨
    수정 가능한 프로퍼티는 인스턴스 자체에 저장

  37 this의 명시적인 바인딩에 대해 이해하라
    this 스코프는 항상 가장 가까이 둘러싼 함수에 의해 결정
    bind 함수 혹은 self, me, that 지역 변수 이름을 활용하자

  38 서브 클래스 생성자에서 수퍼 클래스 생성자를 호출하라
    서브 클래스 생성할때 수퍼클래스를 생성자를 명시적으로 호출

  39 수퍼 클래스 프로퍼티 이름을 절대 재사용하지 마라

  40 표준 클래스를 상속하지 마라
    Array, Function, Date 등은 표준 클래스는 내부 메서드나 프로퍼티들이 표준 클래스에서만 동작되게 되어있을 수 있다
    상속대신 프로퍼티로 표준 클래스들을 활용하자

  41 프로토타입을 세부 구현 사항처럼 처리하라
    프로토타입 내부 프로퍼티들은 객체 내부를 구현하는 일부분이다.
    제어 되지 않는 프로퍼티들을 검사 및 사용하지마라
    객체는 인터페이스이고 프로토타입은 구현체

  42 무모한 몽키 패칭을 하지 마라
    몽키 패칭 : 프로토타입 내용을 수정, 삭제한 경우
    몽키 패칭은 표준 API가 없을 경우 폴리필을 제공하기 위해 사용

5장 배열과 딕셔너리
  43 직접적인 객체의 인스턴스로 가벼운 딕셔너리를 만들어라
    리터럴 객체를 사용하자

  44 프로토타입 오염을 막기 위해 null 프로토타입을 사용하라
    __proto__ = null 로 빈 객체를 만들 수 있지만 하지마라...

  45 프로토타입 오염을 막기 위해 asOwnProperty를 사용하라
    Object.hasOwnProperty로 객체 내부를 검수해야한다. - "toString" in obj === true

  46 순서가 정해진 컬렉션에는 딕셔너리 대신 배열을 사용하라
    객체의 프로퍼티를 열거할때 순서에 의존하지 않도록 개발
    순서가 필요하다면 배열을 사용하자

  47 Object.prototype에 열거 가능한 프로퍼티를 절대 추가하지 마라

  48 열거하는 동안 객체를 수정하지 마라
    프로토타입 그냥 쓰지말자...
    es6로 쓰고 다양한 환경에 맞게 트랜스(babel, ...)하자

    for문으로 프로퍼티 순회하는 동안 프로퍼티 추가시 비정상적으로 작동

  49 배열을 반복할 때 for...in 대신 for 반복문을 사용하라
    in 연산자는 프로퍼티 인자를 건드릴 수도 있다.
    전통적인 for문, 혹은 내장 메서드, 이터러블 객체를 사용하자
    
  50 반복문 대신 반복 메서드를 사용하라
    가독성면에서 내장 메서드를 사용하자
    흐름 제어(continue, break)할때는 전통적인 for문을 사용하자
    필요하다면 사용자 반복 메서드를 사용하자

  51 유사 배열 객체에 범용적인 배열 메서드를 재사용하라
    어떤 유사 배열에서 배열처럼 동작할 수 있도록 하자

  52 Array 생성자 대신 배열 리터럴을 사용하라
    Array(숫자) 시 다르게 동작 또는 Array = String; a = new Array(); 문제가 많다...

6장 라이브러리와 API 설계
  53 일관된 컨벤션을 유지하라
    일관성 문제
  54 undefined를 ‘값 이 없는’ 것처럼 처리하라
    특정한 값이 존재않는 사실을 제외하곤 쓰지말자
    의도한 초기값을 주자

  55 키워드 인자를 위해 옵션 객체를 받아들여라
    옵션객체는 반드시 부가적으로 처리해야한다.
    옵션 값을 추상화(구조 선언 및 초기값등등)하자

  56 불필요한 상태 유지를 피하라
    상태에 따라 동작이 달라진다.
    만약 상태가 필요하다면 상태에 따른 동작을 문서화

  57 유연한 인터페이스를 위해 구조화된 형식을 사용하라
    구조적 인터페이스가 유연하다면 굳이 상속할 필요가 없다
    유연한 객체 인터페이스를 위해 덕 타입을 사용하자

  58 배열과 유사 배열 객체를 구별하라
    비슷한 타입의 기능을 절대 오버로딩하지말자
    유사배열에서 배열 기능이 필요할때 배열로 치환하자

  59 과도한 강제 형변환을 피하라
    기대하지 않은 값을 방어하라
    방어적 코딩도 모든 버그를 잡지 못한다

  60 메서드 체이닝을 지원하라
    내용이 명확하고 간결해진다 - a.map().filter().some()
    무상태 연산을 결합하기 위해 체닝을 쓰자

7장 동시성 - js는 이벤트 기반 싱글 스레드
  61 이벤트 큐를 I/O에 블로킹시키지 마라
    이벤트 큐를 정지시키지마라...
    콜백 혹은 프로미스를 쓰자

  62 비동기 시퀀스를 위해 감싸지거나 이름이 지정된 콜백을 사용하라
    과도하게 콜백을 쓰지말자. 가독성

  63 오류를 놓치지 않도록 조심하라
    공통 오류 함수를 작성하고 재사용하자
    명시적으로 처리하자

  64 비동기적인 반복문을 위해 재귀를 사용하라
    반복문은 비동기가 될 수 없다.
    비동기를 반복문을 실행하기 위해 재귀적인 함수를 사용하자

  65 계산 중 이벤트 큐를 블로킹하지 마라
    비용이 많이 든다면 이벤트 루프를 여러개 쪼개서 사용하자

  66 동시성 연산을 수행하기 위해 카운터를 사용하라
    동시성 연산을 구분하기 위해 카운터를 사용

  67 비동기 콜백을 절대 동기적으로 호출하지 마라
    예상치 않은 코드의 간섭이 나옴

  68 더 깔끔한 비동기 로직을 위해 promise를 사용하라
    동시성 콜백, then 결과 로직, catch 에러 로직 등 좋은 구조로 짤 수 있다.
    promise 쓰자...

---

1 회독

- 쉬움 지수 - 0 > 뇌 비우고 봐도 됨
- 메모리 지수 - 5 > 휘발성 그렇게 강하지 않음
- 다회독 지수 - 8 > 주력 js 언어 책을 봐도 되지만 너무 오래됨...

좋은 책인건 분명하지만 es5시절에 나온 책이다. 현재 es13이 나온 시점에서 위의 책 스타일로 코드를 생성하지는 않을 것 같다. 유지보수를 하지 않는한.... ㅠㅜ